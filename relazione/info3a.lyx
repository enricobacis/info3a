#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{graphicx}
\usepackage{hyperxmp}
\usepackage{dtklogos}
\usepackage{listings}
\usepackage{hyperref}

\hypersetup{
    pdftitle = {Progetti di Informatica III-A},
    pdfauthor = {Enrico Bacis},
    pdfsubject = {Elaborati e Progetti del corso di Informatica III-A},
    pdfkeywords = {UniBG, Ingegneria, Informatica, Progetti},
    pdfcreator = {Latex / LyX},
    pdfcopyright = {Creative Commons (CC BY-NC-SA 3.0) 2013 by Enrico Bacis. Some rights reserved.}
}

\lstset{basicstyle=\small,
               columns=[c]flexible,
               frame=single}

\makeatletter
\@addtoreset{section}{part}
\makeatother  
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 5cm*
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
\size giant
Progetti di Informatica III-A
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\align center

\size huge
Enrico Bacis
\end_layout

\begin_layout Standard
\align center

\size large
- 
\shape italic
Università degli Studi di Bergamo
\shape default
 -
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
Elaborati e Progetti di Enrico Bacis ( 
\begin_inset CommandInset href
LatexCommand href
name "enrico.bacis@gmail.com"
target "enrico.bacis@gmail.com"
type "mailto:"

\end_inset

 ) del corso di Informatica III-A tenuto dal Professor Angelo Gargantini
 presso l'Università degli Studi di Bergamo nell'anno accademico 2012/2013.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Questi elaborati sono distribuiti sotto licenza Creative Commons 
\begin_inset CommandInset href
LatexCommand href
name "BY-NC-SA 3.0"
target "http://creativecommons.org/licenses/by-nc-sa/3.0/deed.it"

\end_inset

.
 È possibile redistribuire e modificare questo file mantenendo però queste
 note e senza cambiare il tipo di licenza.
 Non è possibile far pagare questo file o derivati di questo file.
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
href{http://creativecommons.org/licenses/by-nc-sa/3.0/deed.it}{
\backslash
includegraphics[width=5em]{{by-nc-sa.eu}.pdf}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\align right
Versione del Documento: 0.6
\series bold
b
\series default
 - 20130212
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Part
Cyclone
\end_layout

\begin_layout Standard
Cyclone è un dialetto safe del C che permette di prevenire diversi tipi
 di errori e problemi di sicurezza molto comuni in C come buffer overflow,
 stringhe non terminate e dangling pointers.
\end_layout

\begin_layout Standard
Per ottenere questi risultati il linguaggio C è stato esteso con caratteristiche
 come il 
\shape italic
garbage collector
\shape default
, che solleva il programmatore dal dover esplicitamente deallocare la memoria
 con le chiamate 
\series bold
free()
\series default
, riducendo la possibilità di incorrere in dangling pointer o di memoria
 non deallocata al termine del suo utilizzo; il garbage collector infatti
 libera automaticamente la memoria utilizzata da oggetti di cui non esistono
 più puntatori (e che quindi sono safe da cancellare).
\end_layout

\begin_layout Standard
Altra caratteristica importante di Cyclone sono i qualificatori dei puntatori
 che meglio specificano i possibili valori assunti dai puntatori e aggiungono
 controlli sull'utilizzo degli stessi.
 In questo modo Cyclone permette di eseguire in sicurezza operazioni che
 riguardano i puntatori come aritmetica sui puntatori e gestione di stringhe.
 Nel seguito della relazione verranno presi in esame i diversi qualificatori
 e si illustrerà come sono stati usati nel progetto.
\end_layout

\begin_layout Section
Descrizione del progetto
\end_layout

\begin_layout Standard
Il progetto sviluppato è una libreria per la crittografia di stringhe utilizzand
o cifrari a sostituzione con chiavi decise dall'utente.
\end_layout

\begin_layout Standard
La libreria non è stata sviluppata con un solo cifrario in mente, ma è pensata
 in maniera modulare, in modo che sia facile implementare l'utilizzo di
 diversi cifrari di sostituzione e anche crearne di nuovi.
\end_layout

\begin_layout Standard
Come esempi sono state scritte le funzioni per cifrare testi utilizzando
 il cifrario di Cesare e il cifrario ROT13 oltre al caso di chiave decisa
 dall'utente.
\end_layout

\begin_layout Standard
Oltre a questo sono anche state re-implementate in Cyclone alcune funzioni
 di supporto per le stringhe come strcpy e strncpy in maniera safe a differenza
 delle loro controparti in C.
 
\end_layout

\begin_layout Subsection
Scelta e motivazioni
\end_layout

\begin_layout Standard
E' stato scelto di creare una libreria e non un programma perché trattandosi
 di un piccolo progetto, di seguire l'approccio migliore per la stesura
 di un programma specifico, ovvero quella di creare un insieme di funzionalità
 che non siano dipendenti dal programma stesso ma che possano essere riutilizzat
e anche in altri progetti.
\end_layout

\begin_layout Standard
E' stata dedicata particolare attenzione anche alla suddivisione delle funzioni
 in modo da seguire un approccio DRY
\begin_inset Foot
status open

\begin_layout Plain Layout
Don't Repeat Yourself
\end_layout

\end_inset

 e una buona architettura del software individuando i casi generali e utilizzand
o questi nella codifica delle funzioni a più specifiche.
\end_layout

\begin_layout Standard
Il codice è stato scritto direttamente in Cyclone senza effettuare porting,
 per vedere quanto sforzo sia necessario per un programmatore C iniziare
 un nuovo progetto avendo cura di scriverlo in un linguaggio Safe come Cyclone.
 Si è quindi voluto verificare quanto la stesura di codice nativo in Cyclone
 sia più complessa di quella in C (non è infatti possibile pensare di scrivere
 nuovi applicativi avendo una fase di scrittura in C e una di correzione
 in Cyclone).
\end_layout

\begin_layout Standard
Vista la semplicità di utilizzo delle caratteristiche di Cyclone e la sua
 somiglianza con C, lo sforzo richiesto al programmatore è minimo e i concetti
 vengono assimilati in breve tempo.
\end_layout

\begin_layout Subsection
Funzionalità principali 
\end_layout

\begin_layout Subsubsection
Utilities
\end_layout

\begin_layout Standard

\shape italic
min
\shape default
, 
\shape italic
abs
\shape default
, 
\shape italic
islower
\shape default
, 
\shape italic
isupper
\shape default
, 
\shape italic
isletter
\shape default
, 
\shape italic
isdigit
\end_layout

\begin_layout Subsubsection
String Utilities
\end_layout

\begin_layout Itemize

\series bold
\shape italic
safe_strncpy
\end_layout

\begin_deeper
\begin_layout Standard

\bar under
Descrizione
\bar default
: Copia n caratteri dalla stringa sorgente alla destinazione, o meno se
 la destinazione è più piccola.
\end_layout

\begin_layout Standard

\bar under
Parametri
\bar default
: 
\shape italic
char * @notnull @fat dst, const char * @notnull @fat src, unsigned int n
\end_layout

\begin_layout Standard

\bar under
Tipo di ritorno
\bar default
: 
\shape italic
int
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
\shape italic
safe_strcpy
\end_layout

\begin_deeper
\begin_layout Standard

\bar under
Descrizione
\bar default
: Copia tutto il contenuto della stringa sorgente in quella destinazione,
 o meno se la destinazione è più piccola.
\end_layout

\begin_layout Standard

\bar under
Parametri
\bar default
: 
\shape italic
char * @notnull @fat dst, const char * @notnull @fat src
\end_layout

\begin_layout Standard

\bar under
Tipo di ritorno
\bar default
: 
\shape italic
int
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
\shape italic
strclone
\end_layout

\begin_deeper
\begin_layout Standard

\bar under
Descrizione
\bar default
: Alloca una nuova stringa della dimensione della stringa sorgente e ve
 ne copia il contenuto.
\end_layout

\begin_layout Standard

\bar under
Parametri
\bar default
: 
\shape italic
const char * @notnull @fat src
\end_layout

\begin_layout Standard

\bar under
Tipo di ritorno
\bar default
: 
\shape italic
char * @notnull @fat
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
strswap
\end_layout

\begin_deeper
\begin_layout Standard

\bar under
Descrizione
\bar default
: Restituisce una nuova stringa che è il risultato dell'esecuzione della
 lista di swap applicati alla stringa sorgente.
\end_layout

\begin_layout Standard

\bar under
Parametri
\bar default
: 
\shape italic
const char * @notnull @fat src, int * @notnull @numelts(2) ?swap
\end_layout

\begin_layout Itemize
Il secondo parametro è un array di array di 2 elementi, verrà meglio descritto
 successivamente nella sezione relativa all'utilizzo dei 
\series bold
Bounded Pointers
\series default
.
\end_layout

\begin_layout Standard

\bar under
Tipo di ritorno
\bar default
: 
\shape italic
char * @notnull @fat 
\end_layout

\end_deeper
\begin_layout Subsubsection
Cipher Utilities
\end_layout

\begin_layout Itemize

\series bold
\shape italic
charencrypt
\end_layout

\begin_deeper
\begin_layout Standard

\bar under
Descrizione
\bar default
: Ritorna il carattere 
\shape italic
c
\shape default
 (se alfabetico) nella sua controparte criptata secondo l'algoritmo di sostituzi
one con offset 
\shape italic
off 
\shape default
in avanti.
\end_layout

\begin_layout Standard

\bar under
Parametri
\bar default
: 
\shape italic
char c, int off
\end_layout

\begin_layout Standard

\bar under
Tipo di ritorno
\bar default
: 
\shape italic
char
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
strencrypt
\end_layout

\begin_deeper
\begin_layout Standard

\bar under
Descrizione
\bar default
: Ritorna una nuova stringa nella quale i caratteri alfabetici sono criptati
 secondo l'algoritmo di sostituzione con chiave 
\shape italic
key
\shape default
.
 Se la chiave è più corta della stringa, essa viene re-iterata, se la chiave
 è vuota, viene restituito un errore a schermo (non bloccante) e ritornata
 una stringa vuota.
 Questo tipo di codifica è nota sia come codifica a sostituzione che col
 nome di Codifica di Vigènere.
\end_layout

\begin_layout Standard

\bar under
Parametri
\bar default
: 
\shape italic
const char * @notnull @fat str, int * @notnull @fat key
\end_layout

\begin_layout Standard

\bar under
Tipo di ritorno
\bar default
: 
\shape italic
char * @notnull @fat
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
strdecrypt
\end_layout

\begin_deeper
\begin_layout Standard

\bar under
Descrizione
\bar default
: Ritorna la stringa decrittata con chiave key (vedi strencrypt).
\end_layout

\begin_layout Standard

\bar under
Parametri
\bar default
: 
\shape italic
const char * @notnull @fat str, int * @notnull @fat key
\end_layout

\begin_layout Standard

\bar under
Tipo di ritorno
\bar default
: 
\shape italic
char * @notnull @fat 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
str2key
\end_layout

\begin_deeper
\begin_layout Standard

\bar under
Descrizione
\bar default
: Restituisce un array di interi a partire da una stringa.
 La conversione è una ASCII shiftata in modo da preservare il fatto che
 il carattere '0' sia mappato sul numero 0.
 Questa funzione è utile per genere chiavi per la funzione strencrypt a
 partire da stringhe.
\end_layout

\begin_layout Standard

\bar under
Parametri
\bar default
: 
\shape italic
const char * @notnull @fat str
\end_layout

\begin_layout Standard

\bar under
Tipo di ritorno
\bar default
: 
\shape italic
int ?
\end_layout

\end_deeper
\begin_layout Subsubsection
Ciphers
\end_layout

\begin_layout Itemize

\series bold
cesar
\end_layout

\begin_deeper
\begin_layout Standard

\bar under
Descrizione
\bar default
: Restituisce la stringa cifrata con il cifrario di Cesare con offset 
\shape italic
off
\shape default
.
\end_layout

\begin_layout Standard

\bar under
Parametri
\bar default
: 
\shape italic
const char * @notnull @fat str, int off
\end_layout

\begin_layout Standard

\bar under
Tipo di ritorno
\bar default
: 
\shape italic
char * @notnull @fat 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
rot13
\end_layout

\begin_deeper
\begin_layout Standard

\bar under
Descrizione
\bar default
: Restituisce la stringa cifrata con il cifrario ROT13
\begin_inset Foot
status open

\begin_layout Plain Layout
Caso specifico del cifrario di Cesare con offset 13.
 
\begin_inset CommandInset href
LatexCommand href
name "it.wikipedia.org/wiki/ROT13"
target "http://it.wikipedia.org/wiki/ROT13"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\bar under
Parametri
\bar default
: 
\shape italic
const char * @notnull @fat str
\end_layout

\begin_layout Standard

\bar under
Tipo di ritorno
\bar default
: 
\shape italic
char * @notnull @fat 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
derot13
\end_layout

\begin_deeper
\begin_layout Standard

\bar under
Descrizione
\bar default
: Restituisce la stringa decifrata con il cifrario ROT13
\end_layout

\begin_layout Standard

\bar under
Parametri
\bar default
: 
\shape italic
const char * @notnull @fat str
\end_layout

\begin_layout Standard

\bar under
Tipo di ritorno
\bar default
: 
\shape italic
char * @notnull @fat 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Costrutti Cyclone utilizzati
\end_layout

\begin_layout Standard
Vediamo ora in dettaglio quali sono i costrutti di Cyclone utilizzati nel
 progetto.
\end_layout

\begin_layout Subsection
Puntatori *
\end_layout

\begin_layout Standard
Cyclone permette l'utilizzo di normali puntatori * con le seguenti modifiche
 rispetto a C:
\end_layout

\begin_layout Itemize
Controllo se il puntatore è nullo ad ogni de-reference dello stesso (previene
 Segmentation Fault)
\end_layout

\begin_layout Itemize
Cast vietato da int a puntatore (previene Out of Bounds)
\end_layout

\begin_layout Itemize
Aritmetica dei puntatori vietata (previene Buffer Overflow / Overrun e Out
 of Bounds)
\end_layout

\begin_deeper
\begin_layout Itemize
In realtà quando viene richiesta si procede generando un warning, effettuando
 un cast ad un puntatore @fat con size 1 (vedi qualificatore @fat) e quindi
 successivamente avremo un errore in runtime.
\end_layout

\end_deeper
\begin_layout Standard
Cyclone quindi mette a disposizione dei qualificatori per puntatori che
 meglio specificano gli utilizzi che si possono fare degli stessi.
\end_layout

\begin_layout Subsection
Qualificatore @notnull (puntatore @)
\end_layout

\begin_layout Standard
Controllare ad ogni de-reference che il puntatore non sia nullo può essere
 dispendioso.
 Con questo qualificatore possiamo effettuare il controllo all'assegnamento
 del valore e evitarlo al suo utilizzo.
 E' uno dei più utili ed utilizzati qualificatori di Cyclone insieme a @fat.
\end_layout

\begin_layout Standard
E' stato utilizzato praticamente ovunque nel codice come si può vedere nella
 sezione Funzionalità.
\end_layout

\begin_layout Standard
Può essere espresso sia con: 
\series bold
* @notnull
\series default
 che semplicemente con 
\series bold
@
\end_layout

\begin_layout Subsection
Qualificatore @fat (puntatore ?)
\end_layout

\begin_layout Standard
Questo qualificatore impone che il puntatore su cui viene applicato mantenga
 anche l'informazione sul numero degli elementi dell'array.
 Questo dato è accessibile utilizzando la funzione 
\series bold
numelts(ptr)
\series default
.
\end_layout

\begin_layout Itemize
Permettono aritmetica sui puntatori (con controllo che non si esca dall'array)
\end_layout

\begin_layout Itemize
Tutti gli array possono essere convertiti a @fat (e generalmente viene fatto
 essendo molto utile).
\end_layout

\begin_layout Itemize
Conversione da * a ? automatica con size=1 e warning
\end_layout

\begin_layout Itemize
Conversione da ? a * non problematica (bounds check)
\end_layout

\begin_layout Itemize
Conversione da ? a @ con bounds check e null check
\end_layout

\begin_layout Standard
Questo qualificatore è particolarmente utile per poter conoscere la dimensione
 delle stringhe senza dover utilizzare strlen (e i problemi legati all'uso
 del terminatore 
\backslash
0 generati da questa funzione).
\end_layout

\begin_layout Standard
Come per il puntatore @notnull, anche questo è stato utilizzato praticamente
 ovunque nel codice, ogni qualvolta ci fosse una stringa.
\end_layout

\begin_layout Standard
Può essere espresso sia con: 
\series bold
* @fat
\series default
 che semplicemente con 
\series bold
?
\end_layout

\begin_layout Standard
Esempio con array di interi:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int ?str2key(const char * @notnull @fat str) {
\end_layout

\begin_layout Plain Layout

    return new { for i < numelts(str)-1: *(str+i) - '0' };
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In questo caso non è stato utilizzato anche il qualificatore @notnull perché
 è possibile che la chiave sia nulla.
 Il problema infatti non sta nel creare una chiave nulla, che deve essere
 possibile, ma nel suo utilizzo.
\end_layout

\begin_layout Subsection
Qualificatore @zeroterm
\end_layout

\begin_layout Standard
Qualificatori utilizzati per indicare che gli array a cui puntano sono terminati
 da caratteri 
\backslash
0.
 Utili per la gestione delle stringhe, infatti tutti i puntatori a 
\shape italic
char
\shape default
, fatta eccezione di 
\shape italic
char[]
\shape default
 sono di default 
\shape italic
@zeroterm
\shape default
.
\end_layout

\begin_layout Standard
Esiste anche il qualificatore 
\shape italic
@nozeroterm
\shape default
.
\end_layout

\begin_layout Standard
Permette l'aritmetica dei puntatori (controllando che non vi siano dei terminato
ri di stringa all'interno), ma questo può diventare dispendioso se non utilizzat
o in combinazione con @fat.
\end_layout

\begin_layout Subsection
Bounded Pointers - Qualificatore @numelts(n)
\end_layout

\begin_layout Standard
Indica che il puntatore deve puntare ad un array con esattamente quel numero
 di elementi.
 Se l'array contiene più elementi viene generato un warning, se ne contiene
 di meno un errore.
\end_layout

\begin_layout Standard
E' abbastanza difficile trovare come utilizzarlo, ma con un buon utilizzo
 si presta anche a sostituire delle struct create ad hoc per certe situazioni.
\end_layout

\begin_layout Standard
Nel progetto ad esempio è stato usato per indicare che l'argomento della
 funzione strswap è un'array di array di due elementi, quindi un array di
 coppie (gli elementi della stringa su cui verrà effettuato lo swap).
 Un comportamento simile in C era ottenibile solamente creando una struttura
 
\begin_inset Quotes eld
\end_inset

coppia
\begin_inset Quotes erd
\end_inset

 che contenesse due interi.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

char * @notnull @fat strswap(const char * @notnull @fat src, int * @notnull
 @numelts(2) ?swap) {
\end_layout

\begin_layout Plain Layout

    char * @notnull @fat dst = strclone(src);
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < numelts(swap); i++) {
\end_layout

\begin_layout Plain Layout

        dst[swap[i][0]] = src[swap[i][1]];
\end_layout

\begin_layout Plain Layout

        dst[swap[i][1]] = src[swap[i][0]];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return dst;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Con l'utilizzo di questi puntatori si possono anche creare funzioni che
 ricevono come parametri un array di dimensioni non note a compile time
 e la sua dimensione nel modo:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int f(tag_t num, int [num])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questo tuttavia non sembra essere molto utile visto che si possono utilizzare
 i puntatori @fat.
\end_layout

\begin_layout Subsection
calloc() e Garbage Collector
\end_layout

\begin_layout Standard
La funzione malloc() di C, non garantisce che la memoria allocata sia inizializz
ata.
 La funzione calloc() invece azzera tutti i byte della memoria allocata.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

char * @notnull @fat strclone(const char * @notnull @fat src) {
\end_layout

\begin_layout Plain Layout

    int n = numelts(src);
\end_layout

\begin_layout Plain Layout

    char * @notnull @fat dst = calloc(n, sizeof(char));
\end_layout

\begin_layout Plain Layout

    int m = safe_strcpy(dst, src);
\end_layout

\begin_layout Plain Layout

    return dst;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si è fatto utilizzo del garbage collector, infatti tutte le variabili allocate
 nello heap non sono liberate attraverso delle chiamate a 
\series bold
free()
\series default
 ma sono lasciate gestire in maniera automatica dal Garbage Collector, che
 si occuperà di liberare la memoria quando le variabili non sono più referenziat
e da alcun puntatore.
\end_layout

\begin_layout Subsection
Array Comprehension
\end_layout

\begin_layout Standard
E' stato piacevole trovare in Cyclone la funzionalità di Array Comprehension,
 che permette di scrivere, o meglio descrivere delle liste a partire dalle
 loro relazioni con i numeri da 0 a n.
 Ad esempio si può ottenere la lista dei numeri pari da 0 a 200 moltiplicando
 per 2 i numeri da 0 a 100.
 Questa caratteristica è stata spesso usata nel progetto al posto dei cicli
 for, in modo che il codice sia più facile ed intuitivo.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

char * @notnull @fat strdecrypt(const char * @notnull @fat str, int * @notnull
 @fat key) {
\end_layout

\begin_layout Plain Layout

	return strencrypt(str, new { for i < numelts(key): -key[i] });
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questa funzione è simile alle List Comprehension in Python, anche se queste
 ultime sono di gran lunga più potenti.
\end_layout

\begin_layout Subsection
let
\end_layout

\begin_layout Standard
Il costrutto 
\series bold
let
\series default
 permette di dichiarare una variabile e assegnarvi un valore senza dover
 specificare il tipo della variabile; infatti verrà fatta inferenza sul
 tipo del valore assegnato per poi dichiarare la variabile in modo che possa
 contenere quel dato.
 Questo comportamento è da un certo punto di vista simile a quello adottato
 dai linguaggi con dynamic typing e risulta molto utile in un linguaggio
 come Cyclone dove scrivere il tipo della variabile con tutti i suoi qualificato
ri può essere dispendioso.
 In questo modo si lascia al compilatore la scelta del tipo adatto sollevando
 il programmatore dalla scelta e velocizzando l'utilizzo.
 Si può scrivere quindi:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

let str = rot13("hello world");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
invece che:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

char * @notnull @fat str = rot13("hello world");
\end_layout

\end_inset


\end_layout

\begin_layout Section
Supporto allo sviluppo
\end_layout

\begin_layout Standard
Il supporto allo sviluppo è stato una parte centrale del lavoro ed ha impegnato
 diverso tempo per poter trovare dei modi che rendano l'utilizzo di Cyclone
 più facile anche per altri studenti del corso.
 Cyclone infatti è stato purtroppo discontinuato e il suo utilizzo è reso
 difficile dai seguenti problemi:
\end_layout

\begin_layout Enumerate
Necessita la compilazione dei sorgenti per funzionare con GCC 4 e superiori
\end_layout

\begin_layout Enumerate
Non funziona su architetture a 64 bit
\end_layout

\begin_layout Enumerate
Funziona solo su piattaforme UNIX (e Windows utilizzando emulatori di shell
 UNIX come CYGWIN)
\end_layout

\begin_layout Standard
Ognuno di queste voci ha dato spunto a delle riflessioni che hanno portato
 a dei sottoprogetti (a volte più corposi dei progetti stessi) che si spera
 possano servire per i futuri studenti del corso.
\end_layout

\begin_layout Subsection
Cyclone su Ubuntu
\end_layout

\begin_layout Standard
Per ovviare al problema di compilazione con GCC 4 possibile solo con i sorgenti
 scaricabili dal repository SVN di Cyclone, questi ultimi sono stati compilati
 per Ubuntu 32 bit e pacchettizzati in un pacchetto software .deb che necessita
 solo di un doppio click per installare l'intera toolchain Cyclone.
 Il pacchetto è già stato fornito al docente e utilizzato da diversi studenti
 (è infatti attualmente il metodo più facile per utilizzare Cyclone).
\end_layout

\begin_layout Subsection
Autocyc
\end_layout

\begin_layout Standard
Basandosi sul sistema inotify che permette di eseguire delle operazioni
 automaticamente quando si modifica un file, la sincronizzazione con Ubuntu
 One (software simile a Dropbox con sincronizzazione immediata via LAN)
 e il linguaggio di scripting BASH per la shell di Linux, è stato scritto
 un piccolo tool, 
\series bold
autocyc
\series default
, che permette di controllare un file, compilarlo e, in caso la compilazione
 sia positiva, eseguirlo automaticamente.
\end_layout

\begin_layout Standard
Questo procedimento è utile quando si vuole programmare in Cyclone su una
 macchina a 64 bit, compilando automaticamente su un'altra macchina, fisica
 o virtuale, a 32 bit ogni volta che il file viene modificato.
\end_layout

\begin_layout Section
Cyclone Remote Compiler [Bonus]
\end_layout

\begin_layout Standard
Nonostante i due sforzi descritti precedentemente per permettere a me e
 ad altri di compilare correttamente codice Cyclone sulle proprie macchine,
 non ero ancora soddisfatto della semplicità di utilizzo, e non prospettando
 previsioni rosee per il porting a 64 bit di questo linguaggio ho deciso
 di creare 
\series bold
Cyclone Remote Compiler
\series default
.
\end_layout

\begin_layout Standard
Cyclone Remote Compiler è una applicazione web che permette a chiunque voglia
 scrivere del codice in Cyclone di compilarlo remotamente, senza dover installar
e nulla sul proprio PC se non un Browser Web e in maniera indipendente dall'arch
itettura e dal sistema operativo utilizzato.
\end_layout

\begin_layout Subsection
Funzionalità
\end_layout

\begin_layout Standard
Cyclone Remote Compiler è, al momento della stesura di questo documento,
 giunto alla versione 1.5 e permette di:
\end_layout

\begin_layout Itemize
Compilare un singolo file .cyc di dimensioni fino a 200 kB.
\end_layout

\begin_layout Itemize
Tempo massimo di compilazione e di esecuzione 5+5 secondi, dopo i quali
 l'applicazione si presume in loop e viene terminata segnalando il motivo
 dell'arresto.
\end_layout

\begin_layout Itemize
Visualizzazione dell'output di compilazione e, se non vi sono errori, di
 quello di esecuzione.
\end_layout

\begin_layout Itemize
Mantenimento della path del file da caricare durante la sessione, in questo
 modo per ricompilare basta modificare il file e cliccare su 
\begin_inset Quotes eld
\end_inset

compile
\begin_inset Quotes erd
\end_inset

 senza dover riselezionare il file.
\end_layout

\begin_layout Itemize
Last but not the least: cura grafica dell'applicazione con animazioni e
 syntax highlight del codice sorgente inviato.
\end_layout

\begin_layout Subsection
Tecnologie
\end_layout

\begin_layout Standard
Le tecnologie utilizzate per questo progetto sono state:
\end_layout

\begin_layout Description
HTML
\begin_inset space ~
\end_inset

5,
\begin_inset space ~
\end_inset

CSS
\begin_inset space ~
\end_inset

3.0,
\begin_inset space ~
\end_inset

Javascript
\begin_inset space ~
\end_inset

e
\begin_inset space ~
\end_inset

jQuery Per la parte di presentazione e animazione della pagina web e per
 il controllo del file sorgente.
\end_layout

\begin_layout Description
AJAX
\begin_inset space ~
\end_inset

e
\begin_inset space ~
\end_inset

XHR2 Per l'invio del file sorgente in maniera trasparente all'utente.
\end_layout

\begin_layout Description
Apache
\begin_inset space ~
\end_inset

e
\begin_inset space ~
\end_inset

PHP Per l'elaborazione del file sorgente, per richiamare il compilatore,
 eseguire il compilato e restituire i risultati di compilazione ed esecuzione.
\end_layout

\begin_layout Description
Github Per l'hosting del codice sorgente di Cyclone Remote Compiler.
\end_layout

\begin_layout Description
AWS Amazon Web Services per l'hosting temporaneo dell'applicazione.
\end_layout

\begin_layout Description
Google
\begin_inset space ~
\end_inset

Prettify Per la funzionalità di Syntax Highlighting del codice sorgente
 visualizzato.
\end_layout

\begin_layout Description
NO-IP Per l'assegnazione di un indirizzo pubblico per raggiungere la macchina
 virtuale hostata su Amazon Web Services.
\end_layout

\begin_layout Subsection
Conclusione
\end_layout

\begin_layout Standard
Cyclone Remote Compiler è disponibile su github per chiunque voglia contribuire
 e, al momento della stesura di questo elaborato, è raggiungibile al sito:
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset href
LatexCommand href
name "http://cyclone.hopto.org"
target "http://cyclone.hopto.org"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Si spera che Cyclone Remote Compiler possa diventare un valido strumento
 di aiuto all'insegnamento, allo sviluppo e al testing di Cyclone.
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Part
C++
\end_layout

\begin_layout Section
Descrizione del progetto
\end_layout

\begin_layout Standard
Il progetto sviluppato rappresenta la struttura di una Università, con tre
 tipi di persone che vi interagiscono:
\end_layout

\begin_layout Description
Studente può conseguire delle votazioni relative ai corsi.
\end_layout

\begin_layout Description
Professore può insegnare dei corsi.
\end_layout

\begin_layout Description
Dottorando riunisce in sé sia le caratteristiche dello studente che quelle
 del professore.
\end_layout

\begin_layout Standard
Tutte e tre ereditano (nel caso di Dottorando in maniera indiretta) dalla
 classe astratta Persona.
\end_layout

\begin_layout Standard
Quasi tutte le funzionalità sono svolte attraverso la classe University,
 che permette di immatricolare nuovi studenti, docenti e dottorandi.
\end_layout

\begin_layout Subsection
Obiettivi
\end_layout

\begin_layout Standard
Durante lo sviluppo di questo progetto si ha avuto come obiettivi, più che
 l'effettiva utilità del progetto svolto, l'aspetto didattico che questo
 aveva nell'apprendimento di gran parte delle particolarità di C++.
 Quindi i punti chiave sono stati:
\end_layout

\begin_layout Itemize
Utilizzo di gran parte delle caratteristiche (anche quelle considerate più
 particolari) del C++ cercando di utilizzarle dove risolvano degli effettivi
 problemi, e non cercando di utilizzarle per il solo gusto di usarle (analizzere
mo poi in dettaglio come e dove sono state utilizzate).
\end_layout

\begin_layout Itemize
Utilizzo di una vasta gamma di 
\series bold
Design Patterns
\series default
 (anche questi verranno presi in esame successivamente).
\end_layout

\begin_layout Section
Classi Principali
\end_layout

\begin_layout Description
University (
\shape italic
university.h
\shape default
, 
\shape italic
university.cpp
\shape default
) -- Rappresenta l'università e contiene metodi utili alla sua gestione.
\end_layout

\begin_layout Description
Persona (
\shape italic
persona.h
\shape default
, 
\shape italic
persona.cpp
\shape default
) -- Rappresenta una persona, è una classe astratta, quindi non-instanziabile,
 ma contiene i membri caratteristici di una persona per fornire una base
 comune alle sue sottoclassi.
\end_layout

\begin_layout Description
Studente (
\shape italic
studente.h
\shape default
, 
\shape italic
studente.cpp
\shape default
) -- Sottoclasse di Persona, rappresenta uno studente universitario, con
 una mappa di voti.
\end_layout

\begin_layout Description
Professore (
\shape italic
professore.h
\shape default
, 
\shape italic
professore.cpp
\shape default
) -- Sottoclasse di Persona, rappresenta un Professore, con una lista di
 corsi insegnati.
\end_layout

\begin_layout Description
Dottorando (
\shape italic
dottorando.h
\shape default
, 
\shape italic
dottorando.cpp
\shape default
) -- Sottoclasse sia di Studente che di Professore, rappresenta un Dottorando,
 che fonde le caratteristiche di Professore e di Studente.
\end_layout

\begin_layout Description
VotiContainer (
\shape italic
voticontainer.h
\shape default
, 
\shape italic
voticontainer.cpp
\shape default
) -- E' una mappa che permette di salvare i nomi dei corsi per i quali lo
 studente ha conseguito una valutazione almeno sufficiente.
\end_layout

\begin_layout Description
Voto (
\shape italic
voto.h
\shape default
, 
\shape italic
voto.cpp
\shape default
) -- Coppia di valori che rappresentano il nome del corso e la valutazione
 conseguita dallo studente.
\end_layout

\begin_layout Description
Visitor (
\shape italic
visitor.h
\shape default
) -- Classe astratta di base per tutti i visitor pattern che si vogliono
 costruire sulla gerarchia di Persona.
 Contiene metodi virtuali puri 
\series bold
visit
\series default
 in overload per permettere il double dispatch.
\end_layout

\begin_layout Description
Visitable (
\shape italic
visitable.h
\shape default
) -- Classe astratta di base per tutte le classi che vogliono poter essere
 visitate dai visitor.
 Contiene il metodo virtuale 
\series bold
accept
\series default
 che permette alla classe di accettare i visitor.
\end_layout

\begin_layout Description
Discounter (
\shape italic
discounter.h
\shape default
, 
\shape italic
discounter.cpp
\shape default
) -- Esempio di visitor parametrizzato (si veda la trattazione nella sottosezion
e visitor pattern) che visita la gerarchia persona e ottiene la percentuale
 di sconto che deve essere applicata per l'utilizzo dei servizi universitari
 (come ad esempio la mensa) da parte della persona che accetta il visitor.
\end_layout

\begin_layout Subsection
Altri File
\end_layout

\begin_layout Description
main (
\shape italic
main.cpp
\shape default
) È praticamente una demo sull'utilizzo delle classi.
 Contiene il metodo 
\bar under
main
\bar default
 che viene eseguito all'esecuzione del file compilato.
\end_layout

\begin_layout Description
utilities (
\shape italic
utilities.h, utilities.cpp
\shape default
) Piccola libreria di metodi utili a differenti classi, come un metodo per
 verificare se in una stringa è presente una sottostringa in maniera case
 insensitive.
\end_layout

\begin_layout Section
Principali Costrutti Utilizzati
\end_layout

\begin_layout Subsection
Classi
\end_layout

\begin_layout Standard
Ovviamente tutto il progetto fa largo uso della programmazione ad oggetti
 a utilizza costrutti quali:
\end_layout

\begin_layout Itemize
Costruttori, costruttori multipli e distruttori che puliscono gli oggetti
 creati nello heap
\end_layout

\begin_layout Itemize
Membri e metodi pubblici, protetti e privati
\end_layout

\begin_layout Standard
Inoltre come particolarità del C++ si è anche utilizzato il costrutto 
\series bold
friend
\series default
 che permette ad una classe o ad un metodo di una classe di accedere anche
 ai membri e metodi privati e protetti di un'altra classe.
\end_layout

\begin_layout Subsection
Ereditarietà
\end_layout

\begin_layout Standard
In C++ quando si ha eredità pubblica, allora si ha anche sottotipazione.
 Nel codice si trovano molto spesso ereditarietà pubbliche, questo è l'esempio
 del legame tra Persona e Studente.
\end_layout

\begin_layout Subsubsection
Ereditarietà Privata
\end_layout

\begin_layout Standard
In alcuni casi potremmo però voler estendere una classe senza rendere pubblici
 i membri di quest'ultima.
 In questo modo, analogamente a quanto poi si farà con il pattern Getter/Setter
 (spiegato dopo) si può ottenere:
\end_layout

\begin_layout Itemize
Controllo degli accessi ai membri e metodi della classe ereditata
\end_layout

\begin_layout Itemize
Wrapping dei metodi per effettuare controlli di validità sui dati
\end_layout

\begin_layout Standard
Nel progetto l'ereditarietà privata è usata in due classi.
 Vediamo un estratto dalla classe 
\shape italic
Voto
\shape default
, qui si è voluto limitare l'accesso ai metodi della classe std::pair, evitando
 la modifica del dato dopo la sua scrittura:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Voto: private std::pair <std::string, unsigned short> {
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

	Voto (std::string const& corso, unsigned short voto);
\end_layout

\begin_layout Plain Layout

	virtual ~Voto ();
\end_layout

\begin_layout Plain Layout

	std::string const& getCorso () const;
\end_layout

\begin_layout Plain Layout

	unsigned short getVoto () const;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nella classe 
\shape italic
VotiContainer
\shape default
 si è anche voluto 
\bar under
ri-pubblicizzare
\bar default
 alcuni metodi (questo viene fatto con la keywork 
\series bold
using
\series default
).
 Vediamone un estratto:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class VotiContainer: private std::map <std::string, unsigned short> {
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

	size_t registraVoto (Voto* voto);
\end_layout

\begin_layout Plain Layout

	unsigned short getVoto (std::string const& corso) const;
\end_layout

\begin_layout Plain Layout

	// Ripubblicizzo i metodi che vondo rendere pubblici
\end_layout

\begin_layout Plain Layout

	using std::map<std::string, unsigned short>::const_iterator;
\end_layout

\begin_layout Plain Layout

	using std::map<std::string, unsigned short>::size;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Ereditarietà Multipla
\end_layout

\begin_layout Standard
Una delle caratteristiche fondamentali di C++ è la possibilità di ereditare
 da più classi comportamenti.
 In questo modo il grafo dell'ereditarietà delle classi non è più un albero
 semplice ma una rete.
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename images/cpp-multipleinheritance.png
	width 25col%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Subsubsection
Diamond Problem ed Ereditarietà Virtuale
\end_layout

\begin_layout Standard
Tuttavia l'ereditarietà multipla può portare ad alcuni problemi, infatti
 se si eredita da due classi che hanno tra le loro basi una stessa classe,
 ci si troverebbe con due istanze della stessa base class.
 Il diamond nella nostra gerarchia si chiude con l'inserimento della classe
 Dottorando:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Dottorando: public virtual Studente, public virtual Professore { ...
 };
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il diamante si vede chiaramente dalla rappresentazione UML della gerarchia:
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename images/cpp-diamond.png
	width 25col%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
Il problema del diamond si risolve con l'ereditarietà virtuale, basta infatti
 che Studente e da Professore ereditino virtualmente Persona, in questo
 modo garantiamo che ci sia al più una istanza di Persona anche in caso
 di diamonds:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Studente: public virtual Persona { ...
 };
\end_layout

\begin_layout Plain Layout

class Professore: public virtual Persona { ...
 };
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Overriding e Metodi Virtuali
\end_layout

\begin_layout Standard
In C++, anche in presenza di ereditarietà e di condizioni valide per fare
 l'override di un metodo, di default non viene effettuato override ma overload
 del metodo, e quindi il risultato non è polimorfico: in compilazione non
 viene scelta la segnatura ma il metodo da chiamare, in base quindi al tipo
 del riferimento e non al tipo dell'oggetto.
 Quando invece si vuole fare override è necessario che la base class dichiari
 il metodo come 
\series bold
virtual
\series default
.
\end_layout

\begin_layout Standard
Un esempio nel progetto è il metodo 
\shape italic
virtual void printInfo()
\shape default
, implementato in tutte le classi della gerarchia.
 In questo modo il metodo chiamato in runtime dipenderà dal tipo dell'oggetto
 e non dal tipo del riferimento.
 Quindi scrivendo:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Persona* p = new Studente();
\end_layout

\begin_layout Plain Layout

p->printInfo();
\end_layout

\end_inset

verrà chiamato il metodo printInfo di Studente (se il metodo non fosse stato
 virtual sarebbe stato chiamato quello di Persona).
\end_layout

\begin_layout Standard
Se da un metodo di Studente vogliamo richiamare un metodo di Persona su
 cui è stato fatto override possiamo scrivere:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Persona::printInfo();
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Classi Astratte e Metodi Virtuali Puri
\end_layout

\begin_layout Standard
Per poter dichiarare classi astratte (non instanziabili) in C++ dobbiamo
 fare ricorso a metodi 
\series bold
pure virtual
\series default
 che sono codificati come:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

virtual returnType method (args) = 0;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Le classi astratte nel progetto sono:
\end_layout

\begin_layout Itemize
Visitor
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

virtual void visit (Studente*) = 0;
\end_layout

\begin_layout Plain Layout

virtual void visit (Professore*) = 0;
\end_layout

\begin_layout Plain Layout

virtual void visit (Dottorando*) = 0;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Visitable
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

virtual void accept (Visitor* visitor) = 0;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Persona
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

virtual ~Persona() = 0;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Persona ha anche un secondo metodo virtuale pure che è quello ereditato
 da Visitable che però non estende.
\end_layout

\end_deeper
\begin_layout Standard
Le classi Visitor e Visitable non hanno implementazioni, quindi sono come
 delle interfacce Java.
\end_layout

\begin_layout Subsection
Overload
\end_layout

\begin_layout Standard
Anche l'overload è un concetto fondamentale, un esempio è quello appena
 visto per la classe Visitor che ha tre metodi visit con tre metodi visit
 che però hanno differenti argomenti.
 Si noti che in questo modo si presenta tuttavia il problema del 
\series bold
Double Dispatching
\series default
, che viene risolto poi nella sezione che spiega in dettaglio il Visitor
 Pattern.
\end_layout

\begin_layout Subsubsection
Overload degli operatori
\end_layout

\begin_layout Standard
Altra caratteristica del C++ è quella di poter fare overload di quasi tutti
 i più comuni operatori.
\end_layout

\begin_layout Paragraph
Overload di []
\end_layout

\begin_layout Standard
Utilizzato ad esempio della classe Studente come alias della chiamata a
 
\shape italic
getVoto (string const& corso)
\shape default
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

unsigned short Studente::operator[] (string const& corso) {
\end_layout

\begin_layout Plain Layout

	return getVoto(corso);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Overload di =
\end_layout

\begin_layout Standard
Utilizzato per definire il comportamento dell'assegnamento.
 Nel progetto si usa per inibire l'assegnamento alle istanze di alcune classi
 come University (il metodo viene dichiarato ma mai implementato, in modo
 che il compilatore generi un errore se viene utilizzato).
\end_layout

\begin_layout Paragraph
Overload di <<
\end_layout

\begin_layout Standard
Questo operatore è molto utile insieme agli output stream come 
\series bold
cout
\series default
.
 In questo modo si può definire il comportamento a fronte di una chiamata
 
\shape italic
cout << istanza_della_classe
\shape default
.
 Vediamo l'esempio di VotiContainer:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class VotiContainer: private std::map <std::string, unsigned short> {
\end_layout

\begin_layout Plain Layout

	[ ...
 ]
\end_layout

\begin_layout Plain Layout

	friend std::ostream& operator<< (std::ostream& os, VotiContainer const*
 v);
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ostream& operator<< (ostream& os, VotiContainer const* v) {
\end_layout

\begin_layout Plain Layout

	for (map<string, unsigned short>::const_iterator i = v->begin(); i != v->end();
 ++i)
\end_layout

\begin_layout Plain Layout

		os << i->second << "
\backslash
t" << i->first << endl;
\end_layout

\begin_layout Plain Layout

	return os;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si noti che si è voluto utilizzare un metodo esterno alla classe ma definito
 come friend della stessa, in modo da poter vedere tutti i suoi membri.
 Viene ritornato lo stream stesso per poter concatenare elementi come:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cout << "value = " << istanza_della_classe << "!"
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
STL
\end_layout

\begin_layout Standard
Nel progetto si è fatto un largo utilizzo di tutti gli aspetti delle STL
 per ottenere funzionalità avanzate senza dover codificarle e senza quindi
 rischiare di immettere errori o cali di prestazioni non necessari.
\end_layout

\begin_layout Subsubsection
Strutture
\end_layout

\begin_layout Standard
Le strutture dati che sono state utilizzate sono:
\end_layout

\begin_layout Description
vector Utilizzato nella classe Professore per mantenere una lista di 
\shape italic
std::string
\shape default
 (i corsi insegnati).
\end_layout

\begin_layout Description
unordered_map Utilizzato da University per mantenere una mappa delle persone.
 La chiave della mappa è la matricola, mentre il valore è il puntatore alla
 Persona.
\end_layout

\begin_layout Description
map Esteso da VotiContainer per tener traccia (in maniera ordinata secondo
 registrazione) dei voti dello studente.
 La chiave è il nome del corso, mentre il valore è il voto.
\end_layout

\begin_layout Description
pair Esteso da Voto che rappresenta poi la coppia chiave/valore inserita
 in VotiContainer.
\end_layout

\begin_layout Subsubsection
Iteratori
\end_layout

\begin_layout Standard
Utilizzo degli iteratori per creare algoritmi come quello per il calcolo
 della media in VotiContainer:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

float VotiContainer::getMedia () {
\end_layout

\begin_layout Plain Layout

	if (this->empty())
\end_layout

\begin_layout Plain Layout

		return 0.0f;
\end_layout

\begin_layout Plain Layout

	int sum = 0;
\end_layout

\begin_layout Plain Layout

	for (map<string, unsigned short>::const_iterator i = this->begin(); i !=
 this->end(); ++i)
\end_layout

\begin_layout Plain Layout

		sum += i->second;
\end_layout

\begin_layout Plain Layout

	return ((float) sum) / size();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Altri esempi di utilizzo di iteratori si ritrovano in tutto il codice per
 scorrere ma anche cercare i dati nelle strutture STL.
\end_layout

\begin_layout Subsubsection
Algoritmi
\end_layout

\begin_layout Standard
Un esempio di algoritmo STL è il metodo 
\series bold
transform
\series default
 utilizzato per trasformare in lowercase tutti i caratteri di una stringa
 prima di poter fare la ricerca di una sottostringa in maniera case-insensitive.
 Esempio da utilities:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

bool strfindi(std::string src, std::string str)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	std::transform(src.begin(), src.end(), src.begin(), ::toupper);
\end_layout

\begin_layout Plain Layout

	std::transform(str.begin(), str.end(), str.begin(), ::toupper);
\end_layout

\begin_layout Plain Layout

	return (src.find(str) == std::string::npos) ? false : true;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Pattern
\end_layout

\begin_layout Standard
Un aspetto molto importante, se non fondamentale, dello sviluppo del progetto
 è stata l'attenzione alla comprensione e all'utilizzo dei design pattern
 architetturale.
\end_layout

\begin_layout Subsection
Getter/Setter Pattern
\end_layout

\begin_layout Standard
Tutti i membri 
\begin_inset Quotes eld
\end_inset

interessanti
\begin_inset Quotes erd
\end_inset

 delle varie classi sono definiti comunque privati e sono acceduti da metodi
 getter e setter in modo da poter definire i tipi di azioni permesse e fare
 controllo dei valori impostati.
 Vediamo un esempio di limitazione degli accessi classe Voto (lettura permessa
 ma senza scrittura):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Voto: private std::pair <std::string, unsigned short> {
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

	std::string const& getCorso () const;
\end_layout

\begin_layout Plain Layout

	unsigned short getVoto () const;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un altro esempio dalla classe VotiContainer sul controllo dei valori:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

size_t VotiContainer::registraVoto (Voto* voto) {
\end_layout

\begin_layout Plain Layout

	if (voto->getVoto() < 18 || voto->getVoto() > 30)
\end_layout

\begin_layout Plain Layout

		cout << "È possibile registrare solo voti 18 <= x <= 30";
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

		this->insert(*voto);
\end_layout

\begin_layout Plain Layout

	return this->size();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Singleton Pattern
\end_layout

\begin_layout Standard
La classe 
\shape italic
University
\shape default
 ha un costruttore privato, un membro statico privato, che rappresenta l'istanza
 della classe, che viene acceduto tramite un metodo pubblico 
\shape italic
getInstance
\shape default
.
 In questo modo non è possibile creare altre istanze della classe ma una
 sola istanza è utilizzabile alla volta.
 Inoltre è stata implementata anche la 
\series bold
lazy initialization
\series default
 cioè l'istanza viene creata non quando la classe viene caricata ma alla
 prima richiesta.
 Vediamo un estratto della classe University:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class University {
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

	static University *getInstance ();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private:
\end_layout

\begin_layout Plain Layout

	static University *instance;
\end_layout

\begin_layout Plain Layout

	University ();
\end_layout

\begin_layout Plain Layout

	University (University const& other);
\end_layout

\begin_layout Plain Layout

	void operator= (University const& other);
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Dichiaro la variabile che è stata precedentemente definita
\end_layout

\begin_layout Plain Layout

University *University::instance = NULL;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

University *University::getInstance() {
\end_layout

\begin_layout Plain Layout

	return instance ? instance : (instance = new University());
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Anche il costruttore di copia e il l'operatore = sono stati ridefiniti (e
 non implementati) per non permettere l'alterazione o la copia dell'istanza
 singleton.
\end_layout

\begin_layout Subsection
Facade Pattern
\end_layout

\begin_layout Standard
La classe University è un Facade per Studente, Professore e Dottorando e
 garantisce infatti l'accesso a dei metodi complessi che fanno riferimento
 a queste classi.
 Il pattern è stato implementato ad esempio per i costruttori attraverso
 i seguenti passi:
\end_layout

\begin_layout Itemize
La classe University è 
\series bold
friend
\series default
 di Studente, Professore e Dottorando e fornisce dei metodi per creare delle
 istanze di queste classi e controllarne la creazione.
\end_layout

\begin_layout Itemize
I costruttori delle classi Studente, Professore e Dottorando sono protected;
 inoltre i costruttori di copia e l'operatore = sono privati.
\end_layout

\begin_layout Standard
Così l'unico modo per creare delle istanze è passare dalla classe University,
 che ne assegna una matricola univoca e aggiunge anche l'istanza alla sua
 lista delle persone.
\end_layout

\begin_layout Subsection
Visitor Pattern
\end_layout

\begin_layout Standard
I visitor pattern sono utilissimi per due motivi:
\end_layout

\begin_layout Itemize
Ci permettono di effettuare il 
\series bold
double dispatching
\series default
, e quindi di invocare metodi diversi non sono in base al tipo effettivo
 del chiamante ma anche a quello del chiamato.
\end_layout

\begin_layout Itemize
Ci permettono di creare classi che al loro interno contengono l'intero funzionam
ento di un meccanismo che cambia la sua dinamica al variare del tipo dell'oggett
o.
\end_layout

\begin_deeper
\begin_layout Itemize
In questo progetto si voleva ad esempio avere dei metodi che calcolassero
 in base al tipo di Persona, lo sconto da applicare sui servizi universitari
 quali la mensa: la classe 
\series bold
Discounter
\series default
.
\end_layout

\begin_layout Itemize
Il cambio del meccanismo di calcolo comporterebbe la modifica dello stesso
 in ogni classe.
 Utilizzando i Visitor invece possiamo avere tutta la specifica nella stessa
 classe (l'implementazione del visitor).
\end_layout

\end_deeper
\begin_layout Standard
Per ottenere questo funzionamento sono state definite due classi:
\end_layout

\begin_layout Itemize
Visitor (classe astratta implementata dai visitor)
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Visitor {
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

	virtual ~Visitor() { }
\end_layout

\begin_layout Plain Layout

	virtual void visit (Studente*) = 0;
\end_layout

\begin_layout Plain Layout

	virtual void visit (Professore*) = 0;
\end_layout

\begin_layout Plain Layout

	virtual void visit (Dottorando*) = 0;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Visitable (classe astratta implementata da chi vuole essere visitato)
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Visitable {
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

	virtual ~Visitable() {}
\end_layout

\begin_layout Plain Layout

	virtual void accept (Visitor* visitor) = 0;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La classe che lo estende deve sempre implementare il metodo allo stesso
 modo:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

virtual void accept (Visitor* visitor) { visitor->visit(this); }
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Template Pattern per specifica del tipo restituito
\end_layout

\begin_layout Standard
Per poter definire il tipo di ritorno del visitor è stato utilizzato il
 
\series bold
Template Pattern
\series default
 in modo da specificare il tipo di ritorno del Visitor.
 In questo modo si è creato un wrapper alla classe Visitor che contenga
 anche un campo 
\shape italic
value
\shape default
 che contenga il valore di ritorno del visitor e possa essere acceduto da
 chi ha invocato il visitor sull'oggetto.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

template <typename ReturnType>
\end_layout

\begin_layout Plain Layout

class ReturningVisitor: public Visitor {
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

	ReturnType const& getValue () { return value; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

protected:
\end_layout

\begin_layout Plain Layout

	void setValue (ReturnType const& value) { this->value = value; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private:
\end_layout

\begin_layout Plain Layout

	ReturnType value;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Visitors are Welcome!
\end_layout

\begin_layout Standard
Quante volte nei film di Hollywood abbiamo visto questa frase scritta sui
 cartelli dei pazzi che aspettano l'arrivo degli alieni sui grattacieli
 di New York, e che poi vengono sistematicamente annientanti dagli alieni
 stessi?
\end_layout

\begin_layout Standard
Anche in questo progetto la classe Visitor è dichiarata 
\series bold
friend
\series default
 delle classi nella gerarchia di Persona.
 In questo modo si può trarre vantaggio dalla potenza dei Visitor senza
 dover rinunciare al principio dell'incapsulamento mettendo tutti i metodi
 pubblici.
 I Visitors potranno quindi aver accesso anche ai membri privati e protetti
 delle classi della gerarchia di Persona.
\end_layout

\begin_layout Section
Altro
\end_layout

\begin_layout Standard
Altri costrutti che sono stati utilizzati nel progetto sono:
\end_layout

\begin_layout Itemize
Costruttori di Copia
\end_layout

\begin_layout Itemize
Passaggio per valore (solitamente utilizzato per i tipi primitivi)
\end_layout

\begin_layout Itemize
Passaggio per reference (utilizzato per essere più veloce e snello, con
 costruttori di copia quando è stato necessario salvare una copia dell'oggetto
 all'interno dell'istanza oppure per proteggere e da qualificatori 
\series bold
const
\series default
 per proteggere dalla modifica gli oggetti passati come parametri o ritornati
 (ad esempio per i getter).
\end_layout

\begin_layout Itemize
Passaggio per puntatore (snello ma non previene la delete dell'oggetto)
\end_layout

\end_body
\end_document
